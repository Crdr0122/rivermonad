/* Generated by wayland-scanner 1.24.0 */

#ifndef RIVER_LAYER_SHELL_V1_CLIENT_PROTOCOL_H
#define RIVER_LAYER_SHELL_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_river_layer_shell_v1 The river_layer_shell_v1 protocol
 * layer shell support for river
 *
 * @section page_desc_river_layer_shell_v1 Description
 *
 * This protocol allows the river-window-management-v1 window manager to
 * support the wlr-layer-shell-v1 protocol.
 *
 * The key words "must", "must not", "required", "shall", "shall not",
 * "should", "should not", "recommended", "may", and "optional" in this
 * document are to be interpreted as described in IETF RFC 2119.
 *
 * @section page_ifaces_river_layer_shell_v1 Interfaces
 * - @subpage page_iface_river_layer_shell_v1 - river layer shell global interface
 * - @subpage page_iface_river_layer_shell_output_v1 - layer shell output state
 * - @subpage page_iface_river_layer_shell_seat_v1 - layer shell seat state
 * @section page_copyright_river_layer_shell_v1 Copyright
 * <pre>
 *
 * SPDX-FileCopyrightText: Â© 2025 Isaac Freund
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 * </pre>
 */
struct river_layer_shell_output_v1;
struct river_layer_shell_seat_v1;
struct river_layer_shell_v1;
struct river_output_v1;
struct river_seat_v1;

#ifndef RIVER_LAYER_SHELL_V1_INTERFACE
#define RIVER_LAYER_SHELL_V1_INTERFACE
/**
 * @page page_iface_river_layer_shell_v1 river_layer_shell_v1
 * @section page_iface_river_layer_shell_v1_desc Description
 *
 * This global interface should only be advertised to the client if the
 * river_window_manager_v1 global is also advertised. Binding this interface
 * indicates that the window manager supports layer shell.
 *
 * If the window manager does not bind this interface, the compositor should
 * not allow clients to map layer surfaces. This can be achieved by
 * closing layer surfaces immediately.
 * @section page_iface_river_layer_shell_v1_api API
 * See @ref iface_river_layer_shell_v1.
 */
/**
 * @defgroup iface_river_layer_shell_v1 The river_layer_shell_v1 interface
 *
 * This global interface should only be advertised to the client if the
 * river_window_manager_v1 global is also advertised. Binding this interface
 * indicates that the window manager supports layer shell.
 *
 * If the window manager does not bind this interface, the compositor should
 * not allow clients to map layer surfaces. This can be achieved by
 * closing layer surfaces immediately.
 */
extern const struct wl_interface river_layer_shell_v1_interface;
#endif
#ifndef RIVER_LAYER_SHELL_OUTPUT_V1_INTERFACE
#define RIVER_LAYER_SHELL_OUTPUT_V1_INTERFACE
/**
 * @page page_iface_river_layer_shell_output_v1 river_layer_shell_output_v1
 * @section page_iface_river_layer_shell_output_v1_desc Description
 *
 * The lifetime of this object is tied to the corresponding river_output_v1.
 * This object is made inert when the river_output_v1.removed event is sent
 * and should be destroyed.
 * @section page_iface_river_layer_shell_output_v1_api API
 * See @ref iface_river_layer_shell_output_v1.
 */
/**
 * @defgroup iface_river_layer_shell_output_v1 The river_layer_shell_output_v1 interface
 *
 * The lifetime of this object is tied to the corresponding river_output_v1.
 * This object is made inert when the river_output_v1.removed event is sent
 * and should be destroyed.
 */
extern const struct wl_interface river_layer_shell_output_v1_interface;
#endif
#ifndef RIVER_LAYER_SHELL_SEAT_V1_INTERFACE
#define RIVER_LAYER_SHELL_SEAT_V1_INTERFACE
/**
 * @page page_iface_river_layer_shell_seat_v1 river_layer_shell_seat_v1
 * @section page_iface_river_layer_shell_seat_v1_desc Description
 *
 * The lifetime of this object is tied to the corresponding river_seat_v1.
 * This object is made inert when the river_seat_v1.removed event is sent and
 * should be destroyed.
 * @section page_iface_river_layer_shell_seat_v1_api API
 * See @ref iface_river_layer_shell_seat_v1.
 */
/**
 * @defgroup iface_river_layer_shell_seat_v1 The river_layer_shell_seat_v1 interface
 *
 * The lifetime of this object is tied to the corresponding river_seat_v1.
 * This object is made inert when the river_seat_v1.removed event is sent and
 * should be destroyed.
 */
extern const struct wl_interface river_layer_shell_seat_v1_interface;
#endif

#ifndef RIVER_LAYER_SHELL_V1_ERROR_ENUM
#define RIVER_LAYER_SHELL_V1_ERROR_ENUM
enum river_layer_shell_v1_error {
	/**
	 * the layer_shell_output/seat object was already created.
	 */
	RIVER_LAYER_SHELL_V1_ERROR_OBJECT_ALREADY_CREATED = 0,
};
#endif /* RIVER_LAYER_SHELL_V1_ERROR_ENUM */

#define RIVER_LAYER_SHELL_V1_DESTROY 0
#define RIVER_LAYER_SHELL_V1_GET_OUTPUT 1
#define RIVER_LAYER_SHELL_V1_GET_SEAT 2


/**
 * @ingroup iface_river_layer_shell_v1
 */
#define RIVER_LAYER_SHELL_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_layer_shell_v1
 */
#define RIVER_LAYER_SHELL_V1_GET_OUTPUT_SINCE_VERSION 1
/**
 * @ingroup iface_river_layer_shell_v1
 */
#define RIVER_LAYER_SHELL_V1_GET_SEAT_SINCE_VERSION 1

/** @ingroup iface_river_layer_shell_v1 */
static inline void
river_layer_shell_v1_set_user_data(struct river_layer_shell_v1 *river_layer_shell_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_layer_shell_v1, user_data);
}

/** @ingroup iface_river_layer_shell_v1 */
static inline void *
river_layer_shell_v1_get_user_data(struct river_layer_shell_v1 *river_layer_shell_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_layer_shell_v1);
}

static inline uint32_t
river_layer_shell_v1_get_version(struct river_layer_shell_v1 *river_layer_shell_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_layer_shell_v1);
}

/**
 * @ingroup iface_river_layer_shell_v1
 *
 * This request indicates that the client will no longer use the
 * river_layer_shell_v1 object.
 */
static inline void
river_layer_shell_v1_destroy(struct river_layer_shell_v1 *river_layer_shell_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_layer_shell_v1,
			 RIVER_LAYER_SHELL_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_layer_shell_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_layer_shell_v1
 *
 * It is a protocol error to make this request more than once for a given
 * river_output_v1 object.
 */
static inline struct river_layer_shell_output_v1 *
river_layer_shell_v1_get_output(struct river_layer_shell_v1 *river_layer_shell_v1, struct river_output_v1 *output)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_layer_shell_v1,
			 RIVER_LAYER_SHELL_V1_GET_OUTPUT, &river_layer_shell_output_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_layer_shell_v1), 0, NULL, output);

	return (struct river_layer_shell_output_v1 *) id;
}

/**
 * @ingroup iface_river_layer_shell_v1
 *
 * It is a protocol error to make this request more than once for a given
 * river_seat_v1 object.
 */
static inline struct river_layer_shell_seat_v1 *
river_layer_shell_v1_get_seat(struct river_layer_shell_v1 *river_layer_shell_v1, struct river_seat_v1 *seat)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_layer_shell_v1,
			 RIVER_LAYER_SHELL_V1_GET_SEAT, &river_layer_shell_seat_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_layer_shell_v1), 0, NULL, seat);

	return (struct river_layer_shell_seat_v1 *) id;
}

/**
 * @ingroup iface_river_layer_shell_output_v1
 * @struct river_layer_shell_output_v1_listener
 */
struct river_layer_shell_output_v1_listener {
	/**
	 * area left after subtracting exclusive zones
	 *
	 * This event indicates the area of the output remaining after
	 * subtracting the exclusive zones of layer surfaces. Exclusive
	 * zones are a hint, the window manager is free to ignore this area
	 * hint if it wishes.
	 *
	 * The x and y values are in the global coordinate space, not
	 * relative to the position of the output.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*non_exclusive_area)(void *data,
				   struct river_layer_shell_output_v1 *river_layer_shell_output_v1,
				   int32_t x,
				   int32_t y,
				   int32_t width,
				   int32_t height);
};

/**
 * @ingroup iface_river_layer_shell_output_v1
 */
static inline int
river_layer_shell_output_v1_add_listener(struct river_layer_shell_output_v1 *river_layer_shell_output_v1,
					 const struct river_layer_shell_output_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_layer_shell_output_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_LAYER_SHELL_OUTPUT_V1_DESTROY 0
#define RIVER_LAYER_SHELL_OUTPUT_V1_SET_DEFAULT 1

/**
 * @ingroup iface_river_layer_shell_output_v1
 */
#define RIVER_LAYER_SHELL_OUTPUT_V1_NON_EXCLUSIVE_AREA_SINCE_VERSION 1

/**
 * @ingroup iface_river_layer_shell_output_v1
 */
#define RIVER_LAYER_SHELL_OUTPUT_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_layer_shell_output_v1
 */
#define RIVER_LAYER_SHELL_OUTPUT_V1_SET_DEFAULT_SINCE_VERSION 1

/** @ingroup iface_river_layer_shell_output_v1 */
static inline void
river_layer_shell_output_v1_set_user_data(struct river_layer_shell_output_v1 *river_layer_shell_output_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_layer_shell_output_v1, user_data);
}

/** @ingroup iface_river_layer_shell_output_v1 */
static inline void *
river_layer_shell_output_v1_get_user_data(struct river_layer_shell_output_v1 *river_layer_shell_output_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_layer_shell_output_v1);
}

static inline uint32_t
river_layer_shell_output_v1_get_version(struct river_layer_shell_output_v1 *river_layer_shell_output_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_layer_shell_output_v1);
}

/**
 * @ingroup iface_river_layer_shell_output_v1
 *
 * This request indicates that the client will no longer use the
 * river_layer_shell_output_v1 object and that it may be safely destroyed.
 *
 * This request should be made after the river_output_v1.removed event is
 * received to complete destruction of the output.
 */
static inline void
river_layer_shell_output_v1_destroy(struct river_layer_shell_output_v1 *river_layer_shell_output_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_layer_shell_output_v1,
			 RIVER_LAYER_SHELL_OUTPUT_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_layer_shell_output_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_layer_shell_output_v1
 *
 * Mark this output as the default for new layer surfaces which do not
 * request a specific output themselves. This request overrides any
 * previous set_default request on any river_layer_shell_output_v1 object.
 *
 * If no set_default request is made or if the default output is destroyed,
 * the default output is undefined until the next set_default request.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_layer_shell_output_v1_set_default(struct river_layer_shell_output_v1 *river_layer_shell_output_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_layer_shell_output_v1,
			 RIVER_LAYER_SHELL_OUTPUT_V1_SET_DEFAULT, NULL, wl_proxy_get_version((struct wl_proxy *) river_layer_shell_output_v1), 0);
}

/**
 * @ingroup iface_river_layer_shell_seat_v1
 * @struct river_layer_shell_seat_v1_listener
 */
struct river_layer_shell_seat_v1_listener {
	/**
	 * 
	 *
	 * A layer shell surface will be given exclusive keyboard focus
	 * at the end of the manage sequence in which this event is sent.
	 * The window manager may want to update window decorations or
	 * similar to indicate that no window is focused.
	 *
	 * Until the focus_non_exclusive or focus_none event is sent, all
	 * window manager requests to change focus are ignored.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*focus_exclusive)(void *data,
				struct river_layer_shell_seat_v1 *river_layer_shell_seat_v1);
	/**
	 * 
	 *
	 * A layer shell surface will be given non-exclusive keyboard
	 * focus at the end of the manage sequence in which this event is
	 * sent. The window manager may want to update window decorations
	 * or similar to indicate that no window is focused.
	 *
	 * The window manager continues to control focus and may choose to
	 * focus a different window/shell surface at any time. If the
	 * window manager sets focus during the same manage sequence in
	 * which this event is sent, the layer surface will not be focused.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*focus_non_exclusive)(void *data,
				    struct river_layer_shell_seat_v1 *river_layer_shell_seat_v1);
	/**
	 * 
	 *
	 * No layer shell surface will have keyboard focus at the end of
	 * the manage sequence in which this event is sent. The window
	 * manager may want to return focus to whichever window last had
	 * focus, for example.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*focus_none)(void *data,
			   struct river_layer_shell_seat_v1 *river_layer_shell_seat_v1);
};

/**
 * @ingroup iface_river_layer_shell_seat_v1
 */
static inline int
river_layer_shell_seat_v1_add_listener(struct river_layer_shell_seat_v1 *river_layer_shell_seat_v1,
				       const struct river_layer_shell_seat_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_layer_shell_seat_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_LAYER_SHELL_SEAT_V1_DESTROY 0

/**
 * @ingroup iface_river_layer_shell_seat_v1
 */
#define RIVER_LAYER_SHELL_SEAT_V1_FOCUS_EXCLUSIVE_SINCE_VERSION 1
/**
 * @ingroup iface_river_layer_shell_seat_v1
 */
#define RIVER_LAYER_SHELL_SEAT_V1_FOCUS_NON_EXCLUSIVE_SINCE_VERSION 1
/**
 * @ingroup iface_river_layer_shell_seat_v1
 */
#define RIVER_LAYER_SHELL_SEAT_V1_FOCUS_NONE_SINCE_VERSION 1

/**
 * @ingroup iface_river_layer_shell_seat_v1
 */
#define RIVER_LAYER_SHELL_SEAT_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_river_layer_shell_seat_v1 */
static inline void
river_layer_shell_seat_v1_set_user_data(struct river_layer_shell_seat_v1 *river_layer_shell_seat_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_layer_shell_seat_v1, user_data);
}

/** @ingroup iface_river_layer_shell_seat_v1 */
static inline void *
river_layer_shell_seat_v1_get_user_data(struct river_layer_shell_seat_v1 *river_layer_shell_seat_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_layer_shell_seat_v1);
}

static inline uint32_t
river_layer_shell_seat_v1_get_version(struct river_layer_shell_seat_v1 *river_layer_shell_seat_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_layer_shell_seat_v1);
}

/**
 * @ingroup iface_river_layer_shell_seat_v1
 *
 * This request indicates that the client will no longer use the
 * river_layer_shell_seat_v1 object and that it may be safely destroyed.
 *
 * This request should be made after the river_seat_v1.removed event is
 * received to complete destruction of the seat.
 */
static inline void
river_layer_shell_seat_v1_destroy(struct river_layer_shell_seat_v1 *river_layer_shell_seat_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_layer_shell_seat_v1,
			 RIVER_LAYER_SHELL_SEAT_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_layer_shell_seat_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifdef  __cplusplus
}
#endif

#endif
