/* Generated by wayland-scanner 1.24.0 */

#ifndef RIVER_INPUT_MANAGEMENT_V1_CLIENT_PROTOCOL_H
#define RIVER_INPUT_MANAGEMENT_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_river_input_management_v1 The river_input_management_v1 protocol
 * configure input devices
 *
 * @section page_desc_river_input_management_v1 Description
 *
 * This protocol supports creating/destroying seats, assigning input devices to
 * seats, and configuring input devices (e.g. setting keyboard repeat rate).
 *
 * The key words "must", "must not", "required", "shall", "shall not",
 * "should", "should not", "recommended", "may", and "optional" in this
 * document are to be interpreted as described in IETF RFC 2119.
 *
 * @section page_ifaces_river_input_management_v1 Interfaces
 * - @subpage page_iface_river_input_manager_v1 - input manager global interface
 * - @subpage page_iface_river_input_device_v1 - an input device
 * @section page_copyright_river_input_management_v1 Copyright
 * <pre>
 *
 * SPDX-FileCopyrightText: Â© 2025 Isaac Freund
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 * </pre>
 */
struct river_input_device_v1;
struct river_input_manager_v1;
struct wl_output;

#ifndef RIVER_INPUT_MANAGER_V1_INTERFACE
#define RIVER_INPUT_MANAGER_V1_INTERFACE
/**
 * @page page_iface_river_input_manager_v1 river_input_manager_v1
 * @section page_iface_river_input_manager_v1_desc Description
 *
 * Input manager global interface.
 * @section page_iface_river_input_manager_v1_api API
 * See @ref iface_river_input_manager_v1.
 */
/**
 * @defgroup iface_river_input_manager_v1 The river_input_manager_v1 interface
 *
 * Input manager global interface.
 */
extern const struct wl_interface river_input_manager_v1_interface;
#endif
#ifndef RIVER_INPUT_DEVICE_V1_INTERFACE
#define RIVER_INPUT_DEVICE_V1_INTERFACE
/**
 * @page page_iface_river_input_device_v1 river_input_device_v1
 * @section page_iface_river_input_device_v1_desc Description
 *
 * An input device represents a physical keyboard, mouse, touchscreen, or
 * drawing tablet tool. It is assigned to exactly one seat at a time.
 * By default, all input devices are assigned to the default seat.
 * @section page_iface_river_input_device_v1_api API
 * See @ref iface_river_input_device_v1.
 */
/**
 * @defgroup iface_river_input_device_v1 The river_input_device_v1 interface
 *
 * An input device represents a physical keyboard, mouse, touchscreen, or
 * drawing tablet tool. It is assigned to exactly one seat at a time.
 * By default, all input devices are assigned to the default seat.
 */
extern const struct wl_interface river_input_device_v1_interface;
#endif

#ifndef RIVER_INPUT_MANAGER_V1_ERROR_ENUM
#define RIVER_INPUT_MANAGER_V1_ERROR_ENUM
enum river_input_manager_v1_error {
	RIVER_INPUT_MANAGER_V1_ERROR_INVALID_DESTROY = 0,
};
#endif /* RIVER_INPUT_MANAGER_V1_ERROR_ENUM */

/**
 * @ingroup iface_river_input_manager_v1
 * @struct river_input_manager_v1_listener
 */
struct river_input_manager_v1_listener {
	/**
	 * the server has finished with the input manager
	 *
	 * This event indicates that the server will send no further
	 * events on this object. The client should destroy the object. See
	 * river_input_manager_v1.destroy for more information.
	 */
	void (*finished)(void *data,
			 struct river_input_manager_v1 *river_input_manager_v1);
	/**
	 * new input device
	 *
	 * A new input device has been created.
	 */
	void (*input_device)(void *data,
			     struct river_input_manager_v1 *river_input_manager_v1,
			     struct river_input_device_v1 *id);
};

/**
 * @ingroup iface_river_input_manager_v1
 */
static inline int
river_input_manager_v1_add_listener(struct river_input_manager_v1 *river_input_manager_v1,
				    const struct river_input_manager_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_input_manager_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_INPUT_MANAGER_V1_STOP 0
#define RIVER_INPUT_MANAGER_V1_DESTROY 1
#define RIVER_INPUT_MANAGER_V1_CREATE_SEAT 2
#define RIVER_INPUT_MANAGER_V1_DESTROY_SEAT 3

/**
 * @ingroup iface_river_input_manager_v1
 */
#define RIVER_INPUT_MANAGER_V1_FINISHED_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_manager_v1
 */
#define RIVER_INPUT_MANAGER_V1_INPUT_DEVICE_SINCE_VERSION 1

/**
 * @ingroup iface_river_input_manager_v1
 */
#define RIVER_INPUT_MANAGER_V1_STOP_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_manager_v1
 */
#define RIVER_INPUT_MANAGER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_manager_v1
 */
#define RIVER_INPUT_MANAGER_V1_CREATE_SEAT_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_manager_v1
 */
#define RIVER_INPUT_MANAGER_V1_DESTROY_SEAT_SINCE_VERSION 1

/** @ingroup iface_river_input_manager_v1 */
static inline void
river_input_manager_v1_set_user_data(struct river_input_manager_v1 *river_input_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_input_manager_v1, user_data);
}

/** @ingroup iface_river_input_manager_v1 */
static inline void *
river_input_manager_v1_get_user_data(struct river_input_manager_v1 *river_input_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_input_manager_v1);
}

static inline uint32_t
river_input_manager_v1_get_version(struct river_input_manager_v1 *river_input_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_input_manager_v1);
}

/**
 * @ingroup iface_river_input_manager_v1
 *
 * This request indicates that the client no longer wishes to receive
 * events on this object.
 *
 * The Wayland protocol is asynchronous, which means the server may send
 * further events until the stop request is processed. The client must wait
 * for a river_input_manager_v1.finished event before destroying this
 * object.
 */
static inline void
river_input_manager_v1_stop(struct river_input_manager_v1 *river_input_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_manager_v1,
			 RIVER_INPUT_MANAGER_V1_STOP, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_manager_v1), 0);
}

/**
 * @ingroup iface_river_input_manager_v1
 *
 * This request should be called after the finished event has been received
 * to complete destruction of the object.
 *
 * It is a protocol error to make this request before the finished event
 * has been received.
 *
 * If a client wishes to destroy this object it should send a
 * river_input_manager_v1.stop request and wait for a
 * river_input_manager_v1.finished event. Once the finished event is
 * received it is safe to destroy this object and any other objects created
 * through this interface.
 */
static inline void
river_input_manager_v1_destroy(struct river_input_manager_v1 *river_input_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_manager_v1,
			 RIVER_INPUT_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_input_manager_v1
 *
 * Create a new seat with the given name. Has no effect if a seat with the
 * given name already exists.
 *
 * The default seat with name "default" always exists and does not need to
 * be explicitly created.
 */
static inline void
river_input_manager_v1_create_seat(struct river_input_manager_v1 *river_input_manager_v1, const char *name)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_manager_v1,
			 RIVER_INPUT_MANAGER_V1_CREATE_SEAT, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_manager_v1), 0, name);
}

/**
 * @ingroup iface_river_input_manager_v1
 *
 * Destroy the seat with the given name. Has no effect if a seat with the
 * given name does not exist.
 *
 * The default seat with name "default" cannot be destroyed and attempting
 * to destroy it will have no effect.
 *
 * Any input devices assigned to the destroyed seat at the time of
 * destruction are assigned to the default seat.
 */
static inline void
river_input_manager_v1_destroy_seat(struct river_input_manager_v1 *river_input_manager_v1, const char *name)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_manager_v1,
			 RIVER_INPUT_MANAGER_V1_DESTROY_SEAT, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_manager_v1), 0, name);
}

#ifndef RIVER_INPUT_DEVICE_V1_ERROR_ENUM
#define RIVER_INPUT_DEVICE_V1_ERROR_ENUM
enum river_input_device_v1_error {
	RIVER_INPUT_DEVICE_V1_ERROR_INVALID_REPEAT_INFO = 0,
	RIVER_INPUT_DEVICE_V1_ERROR_INVALID_SCROLL_FACTOR = 1,
	RIVER_INPUT_DEVICE_V1_ERROR_INVALID_MAP_TO_RECTANGLE = 2,
};
#endif /* RIVER_INPUT_DEVICE_V1_ERROR_ENUM */

#ifndef RIVER_INPUT_DEVICE_V1_TYPE_ENUM
#define RIVER_INPUT_DEVICE_V1_TYPE_ENUM
enum river_input_device_v1_type {
	RIVER_INPUT_DEVICE_V1_TYPE_KEYBOARD = 0,
	RIVER_INPUT_DEVICE_V1_TYPE_POINTER = 1,
	RIVER_INPUT_DEVICE_V1_TYPE_TOUCH = 2,
	RIVER_INPUT_DEVICE_V1_TYPE_TABLET = 3,
};
#endif /* RIVER_INPUT_DEVICE_V1_TYPE_ENUM */

/**
 * @ingroup iface_river_input_device_v1
 * @struct river_input_device_v1_listener
 */
struct river_input_device_v1_listener {
	/**
	 * the input device is removed
	 *
	 * This event indicates that the input device has been removed.
	 *
	 * The server will send no further events on this object and ignore
	 * any request (other than river_input_device_v1.destroy) made
	 * after this event is sent. The client should destroy this object
	 * with the river_input_device_v1.destroy request to free up
	 * resources.
	 */
	void (*removed)(void *data,
			struct river_input_device_v1 *river_input_device_v1);
	/**
	 * the type of the input device
	 *
	 * The type of the input device. This event is sent once when the
	 * river_input_device_v1 object is created. The device type cannot
	 * change during the lifetime of the object.
	 */
	void (*type)(void *data,
		     struct river_input_device_v1 *river_input_device_v1,
		     uint32_t type);
	/**
	 * the name of the input device
	 *
	 * The name of the input device. This event is sent once when the
	 * river_input_device_v1 object is created. The device name cannot
	 * change during the lifetime of the object.
	 */
	void (*name)(void *data,
		     struct river_input_device_v1 *river_input_device_v1,
		     const char *name);
};

/**
 * @ingroup iface_river_input_device_v1
 */
static inline int
river_input_device_v1_add_listener(struct river_input_device_v1 *river_input_device_v1,
				   const struct river_input_device_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_input_device_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_INPUT_DEVICE_V1_DESTROY 0
#define RIVER_INPUT_DEVICE_V1_ASSIGN_TO_SEAT 1
#define RIVER_INPUT_DEVICE_V1_SET_REPEAT_INFO 2
#define RIVER_INPUT_DEVICE_V1_SET_SCROLL_FACTOR 3
#define RIVER_INPUT_DEVICE_V1_MAP_TO_OUTPUT 4
#define RIVER_INPUT_DEVICE_V1_MAP_TO_RECTANGLE 5

/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_REMOVED_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_TYPE_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_NAME_SINCE_VERSION 1

/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_ASSIGN_TO_SEAT_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_SET_REPEAT_INFO_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_SET_SCROLL_FACTOR_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_MAP_TO_OUTPUT_SINCE_VERSION 1
/**
 * @ingroup iface_river_input_device_v1
 */
#define RIVER_INPUT_DEVICE_V1_MAP_TO_RECTANGLE_SINCE_VERSION 1

/** @ingroup iface_river_input_device_v1 */
static inline void
river_input_device_v1_set_user_data(struct river_input_device_v1 *river_input_device_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_input_device_v1, user_data);
}

/** @ingroup iface_river_input_device_v1 */
static inline void *
river_input_device_v1_get_user_data(struct river_input_device_v1 *river_input_device_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_input_device_v1);
}

static inline uint32_t
river_input_device_v1_get_version(struct river_input_device_v1 *river_input_device_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_input_device_v1);
}

/**
 * @ingroup iface_river_input_device_v1
 *
 * This request indicates that the client will no longer use the input
 * device object and that it may be safely destroyed.
 */
static inline void
river_input_device_v1_destroy(struct river_input_device_v1 *river_input_device_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_device_v1,
			 RIVER_INPUT_DEVICE_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_device_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_input_device_v1
 *
 * Assign the input device to a seat. All input devices not explicitly
 * assigned to a seat are considered assigned to the default seat.
 *
 * Has no effect if a seat with the given name does not exist.
 */
static inline void
river_input_device_v1_assign_to_seat(struct river_input_device_v1 *river_input_device_v1, const char *name)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_device_v1,
			 RIVER_INPUT_DEVICE_V1_ASSIGN_TO_SEAT, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_device_v1), 0, name);
}

/**
 * @ingroup iface_river_input_device_v1
 *
 * Set repeat rate and delay for a keyboard input device. Has no effect if
 * the device is not a keyboard.
 *
 * Negative values for either rate or delay are illegal. A rate of zero
 * will disable any repeating (regardless of the value of delay).
 */
static inline void
river_input_device_v1_set_repeat_info(struct river_input_device_v1 *river_input_device_v1, int32_t rate, int32_t delay)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_device_v1,
			 RIVER_INPUT_DEVICE_V1_SET_REPEAT_INFO, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_device_v1), 0, rate, delay);
}

/**
 * @ingroup iface_river_input_device_v1
 *
 * Set the scroll factor for a pointer input device. Has no effect if the
 * device is not a pointer.
 *
 * For example, a factor of 0.5 will make scrolling twice as slow while a
 * factor of 3.0 will make scrolling 3 times as fast.
 *
 * Setting a scroll factor less than 0 is a protocol error.
 */
static inline void
river_input_device_v1_set_scroll_factor(struct river_input_device_v1 *river_input_device_v1, wl_fixed_t factor)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_device_v1,
			 RIVER_INPUT_DEVICE_V1_SET_SCROLL_FACTOR, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_device_v1), 0, factor);
}

/**
 * @ingroup iface_river_input_device_v1
 *
 * Map the input device to the given output. Has no effect if the device is
 * not a pointer, touch, or tablet device.
 *
 * If mapped to both an output and a rectangle, the rectangle has priority.
 *
 * Passing null clears an existing mapping.
 */
static inline void
river_input_device_v1_map_to_output(struct river_input_device_v1 *river_input_device_v1, struct wl_output *output)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_device_v1,
			 RIVER_INPUT_DEVICE_V1_MAP_TO_OUTPUT, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_device_v1), 0, output);
}

/**
 * @ingroup iface_river_input_device_v1
 *
 * Map the input device to the given rectangle in the global compositor
 * coordinate space. Has no effect if the device is not a pointer, touch,
 * or tablet device.
 *
 * If mapped to both an output and a rectangle, the rectangle has priority.
 *
 * Width and height must be greater than or equal to 0.
 *
 * Passing 0 for width or height clears an existing mapping.
 */
static inline void
river_input_device_v1_map_to_rectangle(struct river_input_device_v1 *river_input_device_v1, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_input_device_v1,
			 RIVER_INPUT_DEVICE_V1_MAP_TO_RECTANGLE, NULL, wl_proxy_get_version((struct wl_proxy *) river_input_device_v1), 0, x, y, width, height);
}

#ifdef  __cplusplus
}
#endif

#endif
