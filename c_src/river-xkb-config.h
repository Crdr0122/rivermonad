/* Generated by wayland-scanner 1.24.0 */

#ifndef RIVER_XKB_CONFIG_V1_CLIENT_PROTOCOL_H
#define RIVER_XKB_CONFIG_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_river_xkb_config_v1 The river_xkb_config_v1 protocol
 * configure xkbcommon keyboard state
 *
 * @section page_desc_river_xkb_config_v1 Description
 *
 * This protocol allow a client to set the xkbcommon keymap of individual
 * keyboard input devices. It also allows switching between the layouts of a
 * keymap and toggling capslock/numlock state.
 *
 * The key words "must", "must not", "required", "shall", "shall not",
 * "should", "should not", "recommended", "may", and "optional" in this
 * document are to be interpreted as described in IETF RFC 2119.
 *
 * @section page_ifaces_river_xkb_config_v1 Interfaces
 * - @subpage page_iface_river_xkb_config_v1 - xkb config global interface
 * - @subpage page_iface_river_xkb_keymap_v1 - xkbcommon keymap
 * - @subpage page_iface_river_xkb_keyboard_v1 - xkbcommon keyboard device
 * @section page_copyright_river_xkb_config_v1 Copyright
 * <pre>
 *
 * SPDX-FileCopyrightText: Â© 2026 Isaac Freund
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 * </pre>
 */
struct river_input_device_v1;
struct river_xkb_config_v1;
struct river_xkb_keyboard_v1;
struct river_xkb_keymap_v1;

#ifndef RIVER_XKB_CONFIG_V1_INTERFACE
#define RIVER_XKB_CONFIG_V1_INTERFACE
/**
 * @page page_iface_river_xkb_config_v1 river_xkb_config_v1
 * @section page_iface_river_xkb_config_v1_desc Description
 *
 * Global interface for configuring xkb devices.
 *
 * This global should only be advertised if river_input_manager_v1 is
 * advertised as well.
 * @section page_iface_river_xkb_config_v1_api API
 * See @ref iface_river_xkb_config_v1.
 */
/**
 * @defgroup iface_river_xkb_config_v1 The river_xkb_config_v1 interface
 *
 * Global interface for configuring xkb devices.
 *
 * This global should only be advertised if river_input_manager_v1 is
 * advertised as well.
 */
extern const struct wl_interface river_xkb_config_v1_interface;
#endif
#ifndef RIVER_XKB_KEYMAP_V1_INTERFACE
#define RIVER_XKB_KEYMAP_V1_INTERFACE
/**
 * @page page_iface_river_xkb_keymap_v1 river_xkb_keymap_v1
 * @section page_iface_river_xkb_keymap_v1_desc Description
 *
 * This object is the result of attempting to create an xkbcommon keymap.
 * @section page_iface_river_xkb_keymap_v1_api API
 * See @ref iface_river_xkb_keymap_v1.
 */
/**
 * @defgroup iface_river_xkb_keymap_v1 The river_xkb_keymap_v1 interface
 *
 * This object is the result of attempting to create an xkbcommon keymap.
 */
extern const struct wl_interface river_xkb_keymap_v1_interface;
#endif
#ifndef RIVER_XKB_KEYBOARD_V1_INTERFACE
#define RIVER_XKB_KEYBOARD_V1_INTERFACE
/**
 * @page page_iface_river_xkb_keyboard_v1 river_xkb_keyboard_v1
 * @section page_iface_river_xkb_keyboard_v1_desc Description
 *
 * This object represent a physical keyboard which has its configuration and
 * state managed by xkbcommon.
 * @section page_iface_river_xkb_keyboard_v1_api API
 * See @ref iface_river_xkb_keyboard_v1.
 */
/**
 * @defgroup iface_river_xkb_keyboard_v1 The river_xkb_keyboard_v1 interface
 *
 * This object represent a physical keyboard which has its configuration and
 * state managed by xkbcommon.
 */
extern const struct wl_interface river_xkb_keyboard_v1_interface;
#endif

#ifndef RIVER_XKB_CONFIG_V1_ERROR_ENUM
#define RIVER_XKB_CONFIG_V1_ERROR_ENUM
enum river_xkb_config_v1_error {
	RIVER_XKB_CONFIG_V1_ERROR_INVALID_DESTROY = 0,
	RIVER_XKB_CONFIG_V1_ERROR_INVALID_FORMAT = 1,
};
#endif /* RIVER_XKB_CONFIG_V1_ERROR_ENUM */

#ifndef RIVER_XKB_CONFIG_V1_KEYMAP_FORMAT_ENUM
#define RIVER_XKB_CONFIG_V1_KEYMAP_FORMAT_ENUM
enum river_xkb_config_v1_keymap_format {
	/**
	 * XKB_KEYMAP_FORMAT_TEXT_V1
	 */
	RIVER_XKB_CONFIG_V1_KEYMAP_FORMAT_TEXT_V1 = 1,
	/**
	 * XKB_KEYMAP_FORMAT_TEXT_V2
	 */
	RIVER_XKB_CONFIG_V1_KEYMAP_FORMAT_TEXT_V2 = 2,
};
#endif /* RIVER_XKB_CONFIG_V1_KEYMAP_FORMAT_ENUM */

/**
 * @ingroup iface_river_xkb_config_v1
 * @struct river_xkb_config_v1_listener
 */
struct river_xkb_config_v1_listener {
	/**
	 * the server has finished with the object
	 *
	 * This event indicates that the server will send no further
	 * events on this object. The client should destroy the object. See
	 * river_xkb_config_v1.destroy for more information.
	 */
	void (*finished)(void *data,
			 struct river_xkb_config_v1 *river_xkb_config_v1);
	/**
	 * new xkb keyboard
	 *
	 * A new xkbcommon keyboard has been created. Not every
	 * river_input_device_v1 is necessarily an xkbcommon keyboard as
	 * well.
	 */
	void (*xkb_keyboard)(void *data,
			     struct river_xkb_config_v1 *river_xkb_config_v1,
			     struct river_xkb_keyboard_v1 *id);
};

/**
 * @ingroup iface_river_xkb_config_v1
 */
static inline int
river_xkb_config_v1_add_listener(struct river_xkb_config_v1 *river_xkb_config_v1,
				 const struct river_xkb_config_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_xkb_config_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_XKB_CONFIG_V1_STOP 0
#define RIVER_XKB_CONFIG_V1_DESTROY 1
#define RIVER_XKB_CONFIG_V1_CREATE_KEYMAP 2

/**
 * @ingroup iface_river_xkb_config_v1
 */
#define RIVER_XKB_CONFIG_V1_FINISHED_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_config_v1
 */
#define RIVER_XKB_CONFIG_V1_XKB_KEYBOARD_SINCE_VERSION 1

/**
 * @ingroup iface_river_xkb_config_v1
 */
#define RIVER_XKB_CONFIG_V1_STOP_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_config_v1
 */
#define RIVER_XKB_CONFIG_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_config_v1
 */
#define RIVER_XKB_CONFIG_V1_CREATE_KEYMAP_SINCE_VERSION 1

/** @ingroup iface_river_xkb_config_v1 */
static inline void
river_xkb_config_v1_set_user_data(struct river_xkb_config_v1 *river_xkb_config_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_xkb_config_v1, user_data);
}

/** @ingroup iface_river_xkb_config_v1 */
static inline void *
river_xkb_config_v1_get_user_data(struct river_xkb_config_v1 *river_xkb_config_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_xkb_config_v1);
}

static inline uint32_t
river_xkb_config_v1_get_version(struct river_xkb_config_v1 *river_xkb_config_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_xkb_config_v1);
}

/**
 * @ingroup iface_river_xkb_config_v1
 *
 * This request indicates that the client no longer wishes to receive
 * events on this object.
 *
 * The Wayland protocol is asynchronous, which means the server may send
 * further events until the stop request is processed. The client must wait
 * for a river_xkb_config_v1.finished event before destroying this object.
 */
static inline void
river_xkb_config_v1_stop(struct river_xkb_config_v1 *river_xkb_config_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_config_v1,
			 RIVER_XKB_CONFIG_V1_STOP, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_config_v1), 0);
}

/**
 * @ingroup iface_river_xkb_config_v1
 *
 * This request should be called after the finished event has been received
 * to complete destruction of the object.
 *
 * It is a protocol error to make this request before the finished event
 * has been received.
 *
 * If a client wishes to destroy this object it should send a
 * river_xkb_config_v1.stop request and wait for a
 * river_xkb_config_v1.finished event. Once the finished event is received
 * it is safe to destroy this object and any other objects created through
 * this interface.
 */
static inline void
river_xkb_config_v1_destroy(struct river_xkb_config_v1 *river_xkb_config_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_config_v1,
			 RIVER_XKB_CONFIG_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_config_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_xkb_config_v1
 *
 * The server must be able to mmap the fd with MAP_PRIVATE.
 * The server will fstat the fd to obtain the size of the keymap.
 * The client must not modify the contents of the fd after making this request.
 * The client should seal the fd with fcntl.
 */
static inline struct river_xkb_keymap_v1 *
river_xkb_config_v1_create_keymap(struct river_xkb_config_v1 *river_xkb_config_v1, int32_t fd, uint32_t format)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_config_v1,
			 RIVER_XKB_CONFIG_V1_CREATE_KEYMAP, &river_xkb_keymap_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_xkb_config_v1), 0, NULL, fd, format);

	return (struct river_xkb_keymap_v1 *) id;
}

/**
 * @ingroup iface_river_xkb_keymap_v1
 * @struct river_xkb_keymap_v1_listener
 */
struct river_xkb_keymap_v1_listener {
	/**
	 * keymap creation succeeded
	 *
	 * The keymap object was successfully created and may be used
	 * with the river_xkb_keyboard_v1.set_keymap request.
	 */
	void (*success)(void *data,
			struct river_xkb_keymap_v1 *river_xkb_keymap_v1);
	/**
	 * keymap creation failed
	 *
	 * The compositor failed to create a keymap from the given
	 * parameters.
	 *
	 * It is a protocol error to use this keymap object with
	 * river_xkb_keyboard_v1.set_keymap.
	 */
	void (*failure)(void *data,
			struct river_xkb_keymap_v1 *river_xkb_keymap_v1,
			const char *error_msg);
};

/**
 * @ingroup iface_river_xkb_keymap_v1
 */
static inline int
river_xkb_keymap_v1_add_listener(struct river_xkb_keymap_v1 *river_xkb_keymap_v1,
				 const struct river_xkb_keymap_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_xkb_keymap_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_XKB_KEYMAP_V1_DESTROY 0

/**
 * @ingroup iface_river_xkb_keymap_v1
 */
#define RIVER_XKB_KEYMAP_V1_SUCCESS_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keymap_v1
 */
#define RIVER_XKB_KEYMAP_V1_FAILURE_SINCE_VERSION 1

/**
 * @ingroup iface_river_xkb_keymap_v1
 */
#define RIVER_XKB_KEYMAP_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_river_xkb_keymap_v1 */
static inline void
river_xkb_keymap_v1_set_user_data(struct river_xkb_keymap_v1 *river_xkb_keymap_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_xkb_keymap_v1, user_data);
}

/** @ingroup iface_river_xkb_keymap_v1 */
static inline void *
river_xkb_keymap_v1_get_user_data(struct river_xkb_keymap_v1 *river_xkb_keymap_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_xkb_keymap_v1);
}

static inline uint32_t
river_xkb_keymap_v1_get_version(struct river_xkb_keymap_v1 *river_xkb_keymap_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_xkb_keymap_v1);
}

/**
 * @ingroup iface_river_xkb_keymap_v1
 *
 * This request indicates that the client will no longer use the keymap
 * object and that it may be safely destroyed.
 */
static inline void
river_xkb_keymap_v1_destroy(struct river_xkb_keymap_v1 *river_xkb_keymap_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keymap_v1,
			 RIVER_XKB_KEYMAP_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keymap_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef RIVER_XKB_KEYBOARD_V1_ERROR_ENUM
#define RIVER_XKB_KEYBOARD_V1_ERROR_ENUM
enum river_xkb_keyboard_v1_error {
	RIVER_XKB_KEYBOARD_V1_ERROR_INVALID_KEYMAP = 0,
};
#endif /* RIVER_XKB_KEYBOARD_V1_ERROR_ENUM */

/**
 * @ingroup iface_river_xkb_keyboard_v1
 * @struct river_xkb_keyboard_v1_listener
 */
struct river_xkb_keyboard_v1_listener {
	/**
	 * the xkb keyboard is removed
	 *
	 * This event indicates that the xkb keyboard has been removed.
	 *
	 * The server will send no further events on this object and ignore
	 * any request (other than river_xkb_keyboard_v1.destroy) made
	 * after this event is sent. The client should destroy this object
	 * with the river_xkb_keyboard_v1.destroy request to free up
	 * resources.
	 */
	void (*removed)(void *data,
			struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1);
	/**
	 * corresponding river input device
	 *
	 * The river_input_device_v1 corresponding to this xkb keyboard.
	 * This event will always be the first event sent on the
	 * river_xkb_keyboard_v1 object, and it will be sent exactly once.
	 */
	void (*input_device)(void *data,
			     struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1,
			     struct river_input_device_v1 *device);
	/**
	 * currently active layout
	 *
	 * The currently active layout index and name. The name arg may
	 * be null if the active layout does not have a name.
	 *
	 * This event is sent once when the river_xkb_keyboard_v1 is
	 * created and again whenever the layout changes.
	 */
	void (*layout)(void *data,
		       struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1,
		       uint32_t index,
		       const char *name);
	/**
	 * capslock is currently enabled
	 *
	 * Capslock is currently enabled for the keyboard.
	 *
	 * This event is sent once when the river_xkb_keyboard_v1 is
	 * created and again whenever the capslock state changes.
	 */
	void (*capslock_enabled)(void *data,
				 struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1);
	/**
	 * capslock is currently disabled
	 *
	 * Capslock is currently disabled for the keyboard.
	 *
	 * This event is sent once when the river_xkb_keyboard_v1 is
	 * created and again whenever the capslock state changes.
	 */
	void (*capslock_disabled)(void *data,
				  struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1);
	/**
	 * numlock is currently enabled
	 *
	 * Numlock is currently enabled for the keyboard.
	 *
	 * This event is sent once when the river_xkb_keyboard_v1 is
	 * created and again whenever the numlock state changes.
	 */
	void (*numlock_enabled)(void *data,
				struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1);
	/**
	 * numlock is currently disabled
	 *
	 * Numlock is currently disabled for the keyboard.
	 *
	 * This event is sent once when the river_xkb_keyboard_v1 is
	 * created and again whenever the numlock state changes.
	 */
	void (*numlock_disabled)(void *data,
				 struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1);
};

/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
static inline int
river_xkb_keyboard_v1_add_listener(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1,
				   const struct river_xkb_keyboard_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_xkb_keyboard_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_XKB_KEYBOARD_V1_DESTROY 0
#define RIVER_XKB_KEYBOARD_V1_SET_KEYMAP 1
#define RIVER_XKB_KEYBOARD_V1_SET_LAYOUT_BY_INDEX 2
#define RIVER_XKB_KEYBOARD_V1_SET_LAYOUT_BY_NAME 3
#define RIVER_XKB_KEYBOARD_V1_CAPSLOCK_ENABLE 4
#define RIVER_XKB_KEYBOARD_V1_CAPSLOCK_DISABLE 5
#define RIVER_XKB_KEYBOARD_V1_NUMLOCK_ENABLE 6
#define RIVER_XKB_KEYBOARD_V1_NUMLOCK_DISABLE 7

/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_REMOVED_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_INPUT_DEVICE_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_LAYOUT_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_CAPSLOCK_ENABLED_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_CAPSLOCK_DISABLED_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_NUMLOCK_ENABLED_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_NUMLOCK_DISABLED_SINCE_VERSION 1

/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_SET_KEYMAP_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_SET_LAYOUT_BY_INDEX_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_SET_LAYOUT_BY_NAME_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_CAPSLOCK_ENABLE_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_CAPSLOCK_DISABLE_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_NUMLOCK_ENABLE_SINCE_VERSION 1
/**
 * @ingroup iface_river_xkb_keyboard_v1
 */
#define RIVER_XKB_KEYBOARD_V1_NUMLOCK_DISABLE_SINCE_VERSION 1

/** @ingroup iface_river_xkb_keyboard_v1 */
static inline void
river_xkb_keyboard_v1_set_user_data(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_xkb_keyboard_v1, user_data);
}

/** @ingroup iface_river_xkb_keyboard_v1 */
static inline void *
river_xkb_keyboard_v1_get_user_data(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_xkb_keyboard_v1);
}

static inline uint32_t
river_xkb_keyboard_v1_get_version(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1);
}

/**
 * @ingroup iface_river_xkb_keyboard_v1
 *
 * This request indicates that the client will no longer use the keyboard
 * object and that it may be safely destroyed.
 */
static inline void
river_xkb_keyboard_v1_destroy(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keyboard_v1,
			 RIVER_XKB_KEYBOARD_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_xkb_keyboard_v1
 *
 * Set the keymap for the keyboard.
 *
 * It is a protocol error to pass a keymap object for which the
 * river_xkb_keymap_v1.success event was not received.
 */
static inline void
river_xkb_keyboard_v1_set_keymap(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1, struct river_xkb_keymap_v1 *keymap)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keyboard_v1,
			 RIVER_XKB_KEYBOARD_V1_SET_KEYMAP, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1), 0, keymap);
}

/**
 * @ingroup iface_river_xkb_keyboard_v1
 *
 * Set the active layout for the keyboard's keymap. Has no effect if the
 * layout index is out of bounds for the current keymap.
 */
static inline void
river_xkb_keyboard_v1_set_layout_by_index(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1, int32_t index)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keyboard_v1,
			 RIVER_XKB_KEYBOARD_V1_SET_LAYOUT_BY_INDEX, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1), 0, index);
}

/**
 * @ingroup iface_river_xkb_keyboard_v1
 *
 * Set the active layout for the keyboard's keymap. Has no effect if there
 * is no layout with the give name for the keyboard's keymap.
 */
static inline void
river_xkb_keyboard_v1_set_layout_by_name(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1, const char *name)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keyboard_v1,
			 RIVER_XKB_KEYBOARD_V1_SET_LAYOUT_BY_NAME, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1), 0, name);
}

/**
 * @ingroup iface_river_xkb_keyboard_v1
 *
 * Enable capslock for the keyboard.
 */
static inline void
river_xkb_keyboard_v1_capslock_enable(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keyboard_v1,
			 RIVER_XKB_KEYBOARD_V1_CAPSLOCK_ENABLE, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1), 0);
}

/**
 * @ingroup iface_river_xkb_keyboard_v1
 *
 * Disable capslock for the keyboard.
 */
static inline void
river_xkb_keyboard_v1_capslock_disable(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keyboard_v1,
			 RIVER_XKB_KEYBOARD_V1_CAPSLOCK_DISABLE, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1), 0);
}

/**
 * @ingroup iface_river_xkb_keyboard_v1
 *
 * Enable numlock for the keyboard.
 */
static inline void
river_xkb_keyboard_v1_numlock_enable(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keyboard_v1,
			 RIVER_XKB_KEYBOARD_V1_NUMLOCK_ENABLE, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1), 0);
}

/**
 * @ingroup iface_river_xkb_keyboard_v1
 *
 * Disable numlock for the keyboard.
 */
static inline void
river_xkb_keyboard_v1_numlock_disable(struct river_xkb_keyboard_v1 *river_xkb_keyboard_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_xkb_keyboard_v1,
			 RIVER_XKB_KEYBOARD_V1_NUMLOCK_DISABLE, NULL, wl_proxy_get_version((struct wl_proxy *) river_xkb_keyboard_v1), 0);
}

#ifdef  __cplusplus
}
#endif

#endif
